# JavaScript正则表达式

> 目录
>
> 1. 转义语法
> 2. 修饰符
> 3. 和方法配合检测过滤

## 一、创建正则表达式

正则表达式是一种通用的工具，在 [Java](http://c.biancheng.net/java/)Script、[PHP](http://c.biancheng.net/php/)、Java、[Python](http://c.biancheng.net/python/)、[C++](http://c.biancheng.net/cplus/) 等几乎所有的编程语言中都能使用，

但是支持程度不一样

1. JavaScript中是的正则表达式用`RegExp`对象表示

2. 创建

   * 方式一： / 正则匹配/g

   * 方式二：构造函数创建

     通过RegExp()构造函数动态创建正则表达式，第二个参数标识符（可选）

     ```javascript
     new RegExp(pattern[,flags])
     new RegExp('a','ig')
     ```
     

3. 使用 三部曲

   ```javascript
   let res = /\d/  // 设定正则匹配需求
   let str = '1122' // 获取需要匹配的字符串
   let result =  res.test(str) // 返回结果
   ```

4. 理解：正则模具代表一类模糊带棱角的数据， 通常都不是精确匹配，不针对任何数据，只设置关卡，他可以判断该数据是不是你想要得

## 二、后向引用

## 三、量词

1. ？：多个字符最多匹配一个（最多出现一次）
2. 。：出现一次或者多次（最少出现一次）
3. +：匹配至少一个字符串
4. {n}
5. {n,m}
6. {n,}（任意次）

## 四、修饰符

1. g：global，全文搜索，一站到底
2. i：ingore case，忽略大小写，默认大小写敏感
3. m：multiple lines 多行搜索：改变^$的含义

## 五、元字符

1. 正则预设的功能字符

2. 特殊的转译字符    . \ / 。

3. 元字符列表

   ```java
   . 单个任意字符，除了换行符\n与制表符\r 
   \ 转义字符，将具有特殊意义的符号转义成普通符号: \.
   \d 数字[0~9]
   \D 非数字
   \s 空格
   \S 非空格
   \w 字符[字母|数字|下划线]
   \W 非字符
   \b 单词边界( 除了 （字)字母 数字_ 都算单词边界) 
   \B 非单词边界
   例如:
   let reg = /\./   //这里是通过转译符\将.转译了,就单纯的匹配.符号
   let reg = /\\/ || /\//  //注意转译符在前,
   ```

## 六、javascript中配合正则的函数

一、RegExp对象方法

1. test

   正则.test(字符串)匹配成功,返回真,反之

2. exec

   返回首次匹配到的数据，以数组的形式返回

二、String对象的方法

1. search

   字符串.search(正则)ok:return index || error :return  -1

2. match

   字符串.match(正则):ok:return array ||error:return null

3. replace

   字符串.replace(正则,目标字符串)ok return  newString

4. sqlit：通过正则来分割

   字符串.sqlit(正则)ok return [ ]

## 七、正则默认规则

匹配成功就结束，不会继续匹配，区分大小写（通过修饰符来改变默认规则）

## 八、特殊符号

$

()

+

...

{}：限定符

**【限定符+和\*都是贪婪的，也就是说会尽可能多的去匹配，在后边加上?就可以改成非贪婪的，就是尽可能少的满足条件的字符串】**

^n：匹配以n开头的字符串

n&：匹配以n结尾的字符串

[^n]：[^]不包含xx：[  ] 包含xx

n|m：匹配n或者m中的一个

## 九、贪婪/懒惰?

​	贪婪：尽可能的多的匹配

​	懒惰：尽可能少的匹配

```
n+ 贪婪模式为默认
n+? 量词后面带?就是懒惰模式
{n,m}贪婪模式
{n,m}?懒惰模式
```

## 十、子集[]/分组()

1. 子集[ ],代表一个集合

   ```JavaScript
   [1-9]//匹配0~9之间的字符
   [^1-9]// 匹配非0~9之间的字符
   [a-zA-Z1-9]//匹配大小写a-z
   [\u4e00-\u9fa5]//匹配所有的中文
   ```

2. 分组()，()代表一个分组类似数学里的()

   1. 重复单个字符：例如：/d{1,3} 重复任意数字1~3个
   2. 基础之上升级一个将/d{1,3}重复三次：即将这一组数重复多次，得(\d{1,3}\.){3}\d{1,3}通过括号编组：ip地址就是这样匹配的
   3. 理解:((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)的含义关键词2[0-4]\d|25[0-5]|[01]?\d\d?
   4. 匹配到的分组可以通过$1,2,3取到

   ```
   let y = "2021-06-01"
   y.replace(/(d+)-(d+)-(d+)/,"$2/$3/$1"); // "06/01/2018"
   ```

   ```
   let str = 'abcdefg'
   let reg = /(abc)d/ // 就是abc加上d  匹配到abcd
   let val = reg.exec(str)
   console.log(val) //["abcd", "abc", index: 0, input: "abcdefg"]
   //索引0 为匹配的结果，
   //索引1 为第一个子表达式 匹配结果
   //index :首次匹配成功的索引值，
   //input: 匹配目标。
   ```

## 十一、断言/前瞻

1. 在正则表达式中：开始查找之前=>前瞻  ||  查找之后=>后顾

   在JavaScript中：只有前瞻没有后顾

2. 零宽度：不占字符宽度，只是一个位置，它不匹配任何东西（？=pattren）

   零宽度正向断言，（？！pattern）零宽度负向断言

```
//匹配 “Windows2000” 中的 “Windows” ，不匹配 “Windows3.1” 中的 “Windows”。
windows(?=2000) // 匹配2000的windows
windows(?!2000) // 匹配非2000里的windows
1. (?=exp)：在exp后的字符
2. (?<=exp)：在exp之前的字符
1. (?=exp)：在exp后的字符
2. (?<=exp)：在exp之前的字符
```

## 十二、开始匹配

* 匹配普通的字符串//

  1. /a/匹配字母a
  2. /abc/匹配字母abc

* 匹配子集[ ]

  1. [abc]：匹配abc中的一个
  2. [^abc]：匹配非abc中的
  3. [a-z]：匹配a~a小写的

* 匹配符号集

  例如匹配空白,换行制表符啥的

  1. /\d/：匹配所有的数字
  2. /\\./：这是通过转译符转译成.号